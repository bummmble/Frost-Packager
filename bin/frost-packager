#!/usr/bin/env node

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var meow = _interopDefault(require('meow'));
var chalk = _interopDefault(require('chalk'));
var nodeResolve = _interopDefault(require('rollup-plugin-rebase'));
var commonjs = _interopDefault(require('rollup-plugin-commonjs'));
var jsonPlugin = _interopDefault(require('rollup-plugin-json'));
var yamlPlugin = _interopDefault(require('rollup-plugin-yaml'));
var replacePlugin = _interopDefault(require('rollup-plugin-replace'));
var exec = _interopDefault(require('rollup-plugin-exec'));
var path = require('path');
var async = require('async');
var rollup = require('rollup');
var appRootDir = require('app-root-dir');
var fileExists = require('file-exists');
var babel = _interopDefault(require('rollup-plugin-babel'));
var buble = _interopDefault(require('rollup-plugin-buble'));
var frost = _interopDefault(require('babel-preset-frost'));

function getBanner(pkg) {
    var banner = "/*! " + (pkg.name) + " v" + (pkg.version);

    if (pkg.author) {
        if (typeof pkg.author === 'object') {
            banner += "by " + (pkg.author.name) + " <" + (pkg.author.email) + ">";
        }  else if (typeof pkg.author === 'string') {
            banner += "by " + (pkg.author);
        }
    }

    banner += ' */';
    return banner;
}

function generateTargets(node, web, binary) {
    var targets = {};
    targets.node = generateNode(node);
    targets.web = generateWeb(web);
    targets.binary = generateBinary(binary);
    return targets;
}

function generateNode(node) {
    if (node) {
        return [node];
    }

    return [
        'src/server/index.js',
        'src/server/main.js',
        'src/server/server.js',
        'server/index.js',
        'server/server.js',
        'server/main.js',
        'src/server.js',
        'src/index.js'
    ];
}

function generateWeb(web) {
    if (web) {
        return [web];
    }

    return [
        'src/web/index.js',
        'src/web/web.js',
        'src/web.js',
        'src/browser/index.js',
        'src/browser/main.js',
        'src/browser/web.js',
        'src/browser/client.js',
        'src/client/index.js',
        'src/client/main.js',
        'src/client/client.js',
        'client/index.js',
        'client/web.js',
        'client/main.js'
    ];
}

function generateBinary(binary) {
    if (binary) {
        return [binary];
    }
    return ['src/binary.js', 'src/script.js', 'src/cli.js'];
}

function generateOutputMatrix(pkg, binaryOutput) {
    return {
        'node-classic-commonjs': pkg['main'] || null,
        'node-classic-esmodule': pkg['module'] || pkg['jsnext:main'] || null,

        'node-es2015-commonjs': pkg['main:es2015'] || null,
        'node-es2015-esmodule': pkg['es2015'] || pkg['module:es2015'] || null,

        'node-modern-commonjs': pkg['main:modern'] || null,
        'node-modern-esmodule': pkg['module:modern'] || null,

        'binary-binary-commonjs': binaryOutput || null
    };
}

function ammendOutputMatrix(matrix, output) {
    matrix['node-classic-commonjs'] = output + "/node.classic.commonjs.js";
    matrix['node-classic-esmodule'] = output + "/node.classic.esmodule.js";
    matrix['node-es2015-commonjs'] = output + "/node.es2015.commonjs.js";
    matrix['node-es2015-esmodule'] = output + "/node.es2015.esmodule.js";

    matrix['node-modern-commonjs'] = output + "/node.modern.commonjs.js";
    matrix['node-modern-esmodule'] = output + "/node.modern.esmodule.js";
    return matrix;
}

function findBest(candidates) {
    var filtered = candidates.filter(fileExists.sync);
    return filtered[0];
}

function camelize(str) {
    return str.replace(/-(.)/g, function (_, char) {
        return char.toUpperCase();
    });
}

var cache;

var Root = appRootDir.get();
var pkg = require(path.resolve(Root, 'package.json'));

var command = meow("\n    Usage\n        $ frost-packager\n\n    Options\n        --input-node\n        --input-web\n        --input-binary\n\n        --output-folder\n\n        -t, --transpiler\n        -x, --minified,\n        -m, --sourcemap\n        --target-unstable\n\n        -v, --verbose\n        -q, --quiet\n", {
    flags: {
        inputNode: {
            default: null
        },
        inputWeb: {
            default: null
        },
        inputBinary: {
            default: null
        },
        outputFolder: {
            default: null
        },

        transpiler: {
            default: 'babel',
            alias: 't'
        },

        minified: {
            default: false,
            alias: 'x'
        },

        sourcemap: {
            default: true,
            alias: 'm'
        },

        targetUnstable: {
            default: false
        },

        verbose: {
            default: false,
            alias: 'v'
        },

        quiet: {
            default: false,
            alias: 'q'
        }
    }
});

var ref = command.flags;
var verbose = ref.verbose;
var quiet = ref.quiet;
var targetUnstable = ref.targetUnstable;
var outputFolder = ref.outputFolder;
var inputWeb = ref.inputWeb;
var inputNode = ref.inputNode;
var inputBinary = ref.inputBinary;
var minified = ref.minified;
var transpiler = ref.transpiler;
if (verbose) {
    console.log(("Flags: " + (command.flags)));
}

var binaryConfig = pkg.bin;
var binaryOutput = null;
if (binaryConfig) {
    for (var name$1 in binaryConfig) {
        binaryOutput = binaryConfig[name$1];
        break;
    }
}

var outputMatrix = generateOutputMatrix(pkg, binaryOutput);
if (outputFolder) {
    outputMatrix = ammendOutputMatrix(outputMatrix, pkg);
}

var rollupFormat = {
    commonjs: 'cjs',
    esmodule: 'es'
};

var formats = ['esmodule', 'commonjs'];
var name = pkg.name || camelize(pkg.name);
var banner = getBanner(pkg);
var targets = generateTargets(inputNode, inputWeb, inputBinary);

function generateBuilds() {
    try {
        async.eachOfSeries(targets, function (env, targetId, targetCb) {
            var input = findBest(env);
            if (input) {
                async.eachOfSeries(formats, function (format, formatId, formatCb) {
                    var transpilers = getTraspilers(transpiler, {
                        minified: minified,
                        presets: [],
                        plugins: [],
                        targetUnstable: targetUnstable
                    });
                    async.eachOfSeries(transpilers, function (transpilers, transpilerId, transpilerCb) {
                        var outputFile = outputMatrix[(targetId + "-" + transpilerCb + "-" + format)];
                        if (outputFile) {
                            return createBundle({
                                input: input,
                                targetId: targetId,
                                transpilerId: transpilerId,
                                current: current,
                                format: format,
                                outputFile: outputFile,
                                transpilerCb: transpilerCb
                            });
                        } else {
                            return transpilerCb(null);
                        }
                    }, formatCb);
                }, targetCb);
            } else {
                targetCb(null);
            }
        });
    } catch (err) {
        console.error(err);
        process.exit(1);
    }
}

function createBundle(ref) {
    var input = ref.input;
    var targetId = ref.targetId;
    var transpilerId = ref.transpilerId;
    var current = ref.current;
    var format = ref.format;
    var outputFile = ref.outputFile;
    var transpilerCb = ref.transpilerCb;

    var prefix = 'process.env.';
    var vars = {};
    vars[(prefix + "NAME")] = JSON.stringify(pkg.name);
    vars[(prefix + "VERSION")] = JSON.stringify(pkg.version);
    vars[(prefix + "TARGET")] = JSON.stringify(targetId);

    return rollup.rollup({
        input: input,
        cache: cache,
        onwarn: function (warn) { return console.warn(chalk.red(("- " + (warn.message)))); },
        external: function external(dependency) {
            if (dependency == input) {
                return false;
            }

            if (path.isAbsolute(dependency)) {
                var relativePath = path.relative(Root, dependency);
                return Boolean(/node_modules/.exec(relativePath));
            }

            return dependency.charAt(0) !== '.';
        },
        plugins: [
            nodeResolve({
                extensions: ['.mjs', '.js', '.jsx', '.ts', '.tsx', '.json'],
                jsnext: true,
                module: true,
                main: true
            }),
            replacePlugin(vars),
            commonjs({
                include: 'node_modules/**'
            }),
            yamlPlugin(),
            jsonPlugin(),
            current,
            transpilerId === 'binary' ? exec() : null
        ]
    })
    .then(function (ref) {
        var write = ref.write;

        return write({
        banner: transpilerId === 'binary'
            ? ("#!/usr/bin/env node\n\n" + banner)
            : banner,
        file: outputFile,
        format: rollupFormat[format],
        name: name,
        sourcemap: command.flags.sourcemap,
    });
    })
    .then(function () { return transpilerCb(null); })
    .catch(function (err) {
        console.error(err);
        transpilerCb(("Error during bundling " + input + " in " + format + ": Error: " + err));
    });
}

exports.Root = Root;
exports.pkg = pkg;
exports.generateBuilds = generateBuilds;
exports.createBundle = createBundle;
//# sourceMappingURL=frost-packager.map
